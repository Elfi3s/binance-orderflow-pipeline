import { EventEmitter } from 'events';
import WebSocket from 'isomorphic-ws';
import { KlineInterval } from './types/shared';
import { WsFormattedMessage, WsUserDataEvents } from './types/websockets/ws-events-formatted';
import { WsRawMessage } from './types/websockets/ws-events-raw';
import { WSClientConfigurableOptions, WsResponse } from './types/websockets/ws-general';
import { DefaultLogger } from './util/logger';
import { WsKey } from './util/websockets/websocket-util';
export declare interface WebsocketClientV1 {
    on(event: 'reply', listener: (event: WsResponse) => void): this;
    on(event: 'message', listener: (event: WsRawMessage) => void): this;
    on(event: 'formattedMessage', listener: (event: WsFormattedMessage) => void): this;
    on(event: 'formattedUserDataMessage', listener: (event: WsUserDataEvents) => void): this;
    on(event: 'error', listener: (event: {
        wsKey: WsKey;
        error: any;
        rawEvent?: string;
    }) => void): this;
    on(event: 'open' | 'reconnected' | 'reconnecting' | 'close', listener: (event: {
        wsKey: WsKey;
        ws: WebSocket;
        event?: any;
    }) => void): this;
}
/**
 * @deprecated This legacy websocket client creates one websocket connection per topic.
 *
 * If subscribing to a lot of topics, consider using the new multiplex `WebsocketClient`.
 *
 * To split your topics into smaller groups (one connection per group), simply make multiple multiplex WebsocketClient instances.
 */
export declare class WebsocketClientV1 extends EventEmitter {
    private logger;
    private options;
    private wsStore;
    private beautifier;
    private restClientCache;
    private listenKeyStateCache;
    private wsUrlKeyMap;
    constructor(options: WSClientConfigurableOptions, logger?: typeof DefaultLogger);
    private getRestClientOptions;
    connectToWsUrl(url: string, wsKey?: WsKey | string, forceNewConnection?: boolean): WebSocket;
    tryWsSend(wsKey: WsKey | string, wsMessage: string): void;
    tryWsPing(wsKey: WsKey | string): void;
    private onWsOpen;
    private onWsClose;
    private onWsMessage;
    private sendPing;
    private onWsPing;
    private onWsPong;
    /**
     * Closes a connection, if it's even open. If open, this will trigger a reconnect asynchronously.
     * If closed, trigger a reconnect immediately
     */
    private executeReconnectableClose;
    close(wsKey: WsKey | string, shouldReconnectAfterClose?: boolean): void;
    closeAll(shouldReconnectAfterClose?: boolean): void;
    closeWs(ws: WebSocket, shouldReconnectAfterClose?: boolean): void;
    private parseWsError;
    private reconnectWithDelay;
    private clearTimers;
    private clearPingTimer;
    private clearPongTimer;
    private clearReconnectTimer;
    private getWsBaseUrl;
    getWs(wsKey: WsKey | string): WebSocket | undefined;
    private setWsState;
    /**
     * Send WS message to subscribe to topics. Use subscribe() to call this.
     */
    private requestSubscribeTopics;
    /**
     * Send WS message to unsubscribe from topics. Use unsubscribe() to call this.
     */
    private requestUnsubscribeTopics;
    /**
     * Send WS message to unsubscribe from topics.
     */
    requestListSubscriptions(wsKey: WsKey, requestId: number): void;
    /**
     * Send WS message to set property state
     */
    requestSetProperty(wsKey: WsKey, property: 'combined' | string, value: any, requestId: number): void;
    /**
     * Send WS message to get property state
     */
    requestGetProperty(wsKey: WsKey, property: 'combined' | string, requestId: number): void;
    /**
     * --------------------------
     * User data listen key tracking & persistence
     * --------------------------
     **/
    private setKeepAliveListenKeyTimer;
    private sendKeepAliveForMarket;
    private checkKeepAliveListenKey;
    private teardownUserDataListenKey;
    private respawnUserDataStream;
    /**
     * --------------------------
     * Universal market websocket streams (may apply to one or more API markets)
     * --------------------------
     **/
    /**
     * Subscribe to a universal market websocket stream
     */
    subscribeEndpoint(endpoint: string, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to aggregate trades for a symbol in a market category
     */
    subscribeAggregateTrades(symbol: string, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to trades for a symbol in a market category
     * IMPORTANT: This topic for usdm and coinm is not listed in the api docs and might stop working without warning
     */
    subscribeTrades(symbol: string, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to coin index for a symbol in COINM Futures markets
     */
    subscribeCoinIndexPrice(symbol: string, updateSpeedMs?: 1000 | 3000, forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to mark price for a symbol in a market category
     */
    subscribeMarkPrice(symbol: string, market: 'usdm' | 'coinm', updateSpeedMs?: 1000 | 3000, forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to mark price for all symbols in a market category
     */
    subscribeAllMarketMarkPrice(market: 'usdm' | 'coinm', updateSpeedMs?: 1000 | 3000, forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to klines(candles) for a symbol in a market category
     */
    subscribeKlines(symbol: string, interval: KlineInterval, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to continuous contract klines(candles) for a symbol futures
     */
    subscribeContinuousContractKlines(symbol: string, contractType: 'perpetual' | 'current_quarter' | 'next_quarter', interval: KlineInterval, market: 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to index klines(candles) for a symbol in a coinm futures
     */
    subscribeIndexKlines(symbol: string, interval: KlineInterval, forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to index klines(candles) for a symbol in a coinm futures
     */
    subscribeMarkPriceKlines(symbol: string, interval: KlineInterval, forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to mini 24hr ticker for a symbol in market category.
     */
    subscribeSymbolMini24hrTicker(symbol: string, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to mini 24hr mini ticker in market category.
     */
    subscribeAllMini24hrTickers(market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to 24hr ticker for a symbol in any market.
     */
    subscribeSymbol24hrTicker(symbol: string, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to 24hr ticker in any market.
     */
    subscribeAll24hrTickers(market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to rolling window ticker statistics for all market symbols,
     * computed over multiple windows. Note that only tickers that have
     * changed will be present in the array.
     *
     * Notes:
     * - Supported window sizes: 1h,4h,1d.
     * - Supported markets: spot
     */
    subscribeAllRollingWindowTickers(market: 'spot', windowSize: '1h' | '4h' | '1d', forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to best bid/ask for symbol in spot markets.
     */
    subscribeSymbolBookTicker(symbol: string, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to best bid/ask for all symbols in spot markets.
     */
    subscribeAllBookTickers(market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to best bid/ask for symbol in spot markets.
     */
    subscribeSymbolLiquidationOrders(symbol: string, market: 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to best bid/ask for all symbols in spot markets.
     */
    subscribeAllLiquidationOrders(market: 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to partial book depths (snapshots).
     *
     * Note:
     * - spot only supports 1000ms or 100ms for updateMs
     * - futures only support 100, 250 or 500ms for updateMs
     *
     * Use getContextFromWsKey(data.wsKey) to extract symbol from events
     */
    subscribePartialBookDepths(symbol: string, levels: 5 | 10 | 20, updateMs: 100 | 250 | 500 | 1000, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to orderbook depth updates to locally manage an order book.
     *
     * Note that the updatems parameter depends on which market you're trading
     *
     * - Spot: https://binance-docs.github.io/apidocs/spot/en/#diff-depth-stream
     * - USDM Futures: https://binance-docs.github.io/apidocs/futures/en/#diff-book-depth-streams
     *
     * Use getContextFromWsKey(data.wsKey) to extract symbol from events
     */
    subscribeDiffBookDepth(symbol: string, updateMs: 100 | 250 | 500 | 1000 | undefined, market: 'spot' | 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to best bid/ask for all symbols in spot markets.
     */
    subscribeContractInfoStream(market: 'usdm' | 'coinm', forceNewConnection?: boolean): WebSocket;
    /**
     * --------------------------
     * SPOT market websocket streams
     * --------------------------
     **/
    /**
     * Subscribe to aggregate trades for a symbol in spot markets.
     */
    subscribeSpotAggregateTrades(symbol: string, forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to trades for a symbol in spot markets.
     */
    subscribeSpotTrades(symbol: string, forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to candles for a symbol in spot markets.
     */
    subscribeSpotKline(symbol: string, interval: KlineInterval, forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to mini 24hr ticker for a symbol in spot markets.
     */
    subscribeSpotSymbolMini24hrTicker(symbol: string, forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to mini 24hr mini ticker in spot markets.
     */
    subscribeSpotAllMini24hrTickers(forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to 24hr ticker for a symbol in spot markets.
     */
    subscribeSpotSymbol24hrTicker(symbol: string, forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to 24hr ticker in spot markets.
     */
    subscribeSpotAll24hrTickers(forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to best bid/ask for symbol in spot markets.
     */
    subscribeSpotSymbolBookTicker(symbol: string, forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to best bid/ask for all symbols in spot markets.
     */
    subscribeSpotAllBookTickers(forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to top bid/ask levels for symbol in spot markets.
     */
    subscribeSpotPartialBookDepth(symbol: string, levels: 5 | 10 | 20, updateMs?: 1000 | 100, forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to spot orderbook depth updates to locally manage an order book.
     */
    subscribeSpotDiffBookDepth(symbol: string, updateMs?: 1000 | 100, forceNewConnection?: boolean): WebSocket;
    /**
     * Subscribe to a spot user data stream. Use REST client to generate and persist listen key.
     * Supports spot, margin & isolated margin listen keys.
     */
    subscribeSpotUserDataStreamWithListenKey(listenKey: string, forceNewConnection?: boolean, isReconnecting?: boolean): WebSocket | undefined;
    /**
     * Subscribe to spot user data stream - listen key is automaticallyr generated. Calling multiple times only opens one connection.
     */
    subscribeSpotUserDataStream(forceNewConnection?: boolean, isReconnecting?: boolean): Promise<WebSocket | undefined>;
    /**
     * Subscribe to margin user data stream - listen key is automatically generated.
     */
    subscribeMarginUserDataStream(forceNewConnection?: boolean, isReconnecting?: boolean): Promise<WebSocket>;
    /**
     * Subscribe to isolated margin user data stream - listen key is automatically generated.
     */
    subscribeIsolatedMarginUserDataStream(symbol: string, forceNewConnection?: boolean, isReconnecting?: boolean): Promise<WebSocket>;
    /**
     * --------------------------
     * End of SPOT market websocket streams
     * --------------------------
     **/
    /**
     * Subscribe to USD-M Futures user data stream - listen key is automatically generated.
     */
    subscribeUsdFuturesUserDataStream(isTestnet?: boolean, forceNewConnection?: boolean, isReconnecting?: boolean): Promise<WebSocket>;
    /**
     * Subscribe to COIN-M Futures user data stream - listen key is automatically generated.
     */
    subscribeCoinFuturesUserDataStream(isTestnet?: boolean, forceNewConnection?: boolean, isReconnecting?: boolean): Promise<WebSocket>;
}
