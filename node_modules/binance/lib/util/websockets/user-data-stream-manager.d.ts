import { WebsocketClientOptions, WsMarket } from '../../types/websockets/ws-general';
import { DefaultLogger } from '../logger';
import { RestClientOptions } from '../requestUtils';
import { RestClientCache } from './rest-client-cache';
import { MiscUserDataConnectionState, WsKey, WsTopicRequest } from './websocket-util';
import { WsStore } from './WsStore';
import { WSConnectedResult } from './WsStore.types';
export interface UserDataStreamManagerConfig {
    logger: DefaultLogger;
    wsStore: WsStore<WsKey, WsTopicRequest<string>>;
    restClientCache: RestClientCache;
    /** Fn pointers so we don't have direct access to the WS client */
    respawnUserDataFn: (wsKey: WsKey, market: WsMarket, context: {
        symbol?: string;
        isTestnet?: boolean;
        respawnAttempt?: number;
    }) => Promise<void>;
    getWsUrlFn(wsKey: WsKey, connectionType: 'market' | 'userData' | 'wsAPI'): Promise<string>;
    getRestClientOptionsFn: () => RestClientOptions;
    getWsClientOptionsfn: () => WebsocketClientOptions;
    closeWsFn: (wsKey: WsKey, force?: boolean) => any;
    connectFn: (wsKey: WsKey, customUrl?: string | undefined, throwOnError?: boolean) => Promise<WSConnectedResult | undefined>;
}
/**
 * A minimal attempt at separating all the user data stream handling workflows from
 * the rest of the WS Client logic.
 *
 * This abstraction handles:
 *
 * - spawning the ws connection with the listen key
 * - tracking metadata for a connection & the embedded listen key
 * - handling listen key keep-alive triggers
 * - handling ws respawn with listen key checks
 */
export declare class UserDataStreamManager {
    private logger;
    private listenKeyStateCache;
    private wsStore;
    private restClientCache;
    private respawnUserDataStream;
    private closeWsFn;
    private connectFn;
    private getWsUrlFn;
    private getRestClientOptionsFn;
    private getWsClientOptionsfn;
    constructor(config: UserDataStreamManagerConfig);
    getWsStore(): WsStore<WsKey, WsTopicRequest<string, unknown>>;
    subscribeGeneralUserDataStreamWithListenKey(wsKey: WsKey, market: WsMarket, listenKey: string, forceNewConnection?: boolean, miscState?: MiscUserDataConnectionState): Promise<WSConnectedResult | undefined>;
    private setKeepAliveListenKeyTimer;
    private checkKeepAliveListenKey;
    teardownUserDataListenKey(listenKey?: string, ws?: WebSocket): void;
    triggerUserDataReconnectionWorkflow(legacyWsKey: string): Promise<void>;
    private sendKeepAliveForMarket;
}
