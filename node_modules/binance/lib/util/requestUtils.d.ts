import { MainClient } from '../main-client';
import { BinanceBaseUrlKey, OrderIdProperty } from '../types/shared';
import { WsRequestOperationBinance } from '../types/websockets/ws-api';
import { USDMClient } from '../usdm-client';
import { WsKey } from './websockets/websocket-util';
export type RestClient = MainClient | USDMClient;
export interface RestClientOptions {
    api_key?: string;
    api_secret?: string;
    recvWindow?: number;
    syncIntervalMs?: number | string;
    disableTimeSync?: boolean;
    strictParamValidation?: boolean;
    baseUrl?: string;
    baseUrlKey?: BinanceBaseUrlKey;
    parseExceptions?: boolean;
    beautifyResponses?: boolean;
    filterUndefinedParams?: boolean;
    /**
     * Default: false. If true, use testnet when available
     */
    testnet?: boolean;
    /**
     * Enable keep alive for REST API requests (via axios).
     * See: https://github.com/tiagosiebler/bybit-api/issues/368
     */
    keepAlive?: boolean;
    /**
     * When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000.
     * Only relevant if keepAlive is set to true.
     * Default: 1000 (defaults comes from https agent)
     */
    keepAliveMsecs?: number;
    /**
     * Allows you to provide a custom "signMessage" function, e.g. to use node's much faster createHmac method
     *
     * Look in the examples folder for a demonstration on using node's createHmac instead.
     */
    customSignMessageFn?: (message: string, secret: string) => Promise<string>;
}
export type GenericAPIResponse<T = any> = Promise<T>;
export declare function getOrderIdPrefix(network: BinanceBaseUrlKey): string;
export declare function generateNewOrderId(network: BinanceBaseUrlKey): string;
export declare function getBaseURLKeyForWsKey(wsKey: WsKey): BinanceBaseUrlKey;
export declare function requiresWSAPINewClientOID(request: WsRequestOperationBinance<string>, wsKey: WsKey): boolean;
export declare function validateWSAPINewClientOID(request: WsRequestOperationBinance<string>, wsKey: WsKey): void;
export declare function serialiseParams(params?: object, strict_validation?: boolean, encodeValues?: boolean, filterUndefinedParams?: boolean): string;
export interface SignedRequestState {
    requestBody: any;
    serialisedParams: string | undefined;
    timestamp?: number;
    signature?: string;
    recvWindow?: number;
}
export declare function getRESTRequestSignature(data: object & {
    recvWindow?: number;
    signature?: string;
}, options: RestClientOptions, key?: string, secret?: string, timestamp?: number): Promise<SignedRequestState>;
export declare function getServerTimeEndpoint(urlKey: BinanceBaseUrlKey): string;
export declare function getTestnetBaseUrlKey(urlKey: BinanceBaseUrlKey): BinanceBaseUrlKey;
export declare function getRestBaseUrl(clientType: BinanceBaseUrlKey, restClientOptions: RestClientOptions): string;
export declare function isPublicEndpoint(endpoint: string): boolean;
export declare function isWsPong(response: any): any;
export declare function logInvalidOrderId(orderIdProperty: OrderIdProperty, expectedOrderIdPrefix: string, params: object): void;
/**
 * For some topics, the received event does not include any information on the topic the event is for (e.g. book tickers).
 *
 * This method extracts this using available context, to add an "eventType" property if missing.
 *
 * - For the old WebsocketClient, this is extracted using the WsKey.
 * - For the new multiplex Websocketclient, this is extracted using the "stream" parameter.
 */
export declare function appendEventIfMissing(wsMsg: any, wsKey: WsKey, eventType: string | undefined): void;
export declare function asArray<T>(el: T[] | T): T[];
